/**
 * Namf_Communication
 * AMF Communication Service Â© 2019, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.0.alpha-1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "PresenceInfo.h"

namespace oai {
namespace amf {
namespace model {

PresenceInfo::PresenceInfo() {
  m_PraId                    = "";
  m_PraIdIsSet               = false;
  m_PresenceStateIsSet       = false;
  m_TrackingAreaListIsSet    = false;
  m_EcgiListIsSet            = false;
  m_NcgiListIsSet            = false;
  m_GlobalRanNodeIdListIsSet = false;
}

PresenceInfo::~PresenceInfo() {}

void PresenceInfo::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json& j, const PresenceInfo& o) {
  j = nlohmann::json();
  if (o.praIdIsSet()) j["praId"] = o.m_PraId;
  if (o.presenceStateIsSet()) j["presenceState"] = o.m_PresenceState;
  if (o.trackingAreaListIsSet()) j["trackingAreaList"] = o.m_TrackingAreaList;
  if (o.ecgiListIsSet()) j["ecgiList"] = o.m_EcgiList;
  if (o.ncgiListIsSet()) j["ncgiList"] = o.m_NcgiList;
  if (o.globalRanNodeIdListIsSet())
    j["globalRanNodeIdList"] = o.m_GlobalRanNodeIdList;
}

void from_json(const nlohmann::json& j, PresenceInfo& o) {
  if (j.find("praId") != j.end()) {
    j.at("praId").get_to(o.m_PraId);
    o.m_PraIdIsSet = true;
  }
  if (j.find("presenceState") != j.end()) {
    j.at("presenceState").get_to(o.m_PresenceState);
    o.m_PresenceStateIsSet = true;
  }
  if (j.find("trackingAreaList") != j.end()) {
    j.at("trackingAreaList").get_to(o.m_TrackingAreaList);
    o.m_TrackingAreaListIsSet = true;
  }
  if (j.find("ecgiList") != j.end()) {
    j.at("ecgiList").get_to(o.m_EcgiList);
    o.m_EcgiListIsSet = true;
  }
  if (j.find("ncgiList") != j.end()) {
    j.at("ncgiList").get_to(o.m_NcgiList);
    o.m_NcgiListIsSet = true;
  }
  if (j.find("globalRanNodeIdList") != j.end()) {
    j.at("globalRanNodeIdList").get_to(o.m_GlobalRanNodeIdList);
    o.m_GlobalRanNodeIdListIsSet = true;
  }
}

std::string PresenceInfo::getPraId() const {
  return m_PraId;
}
void PresenceInfo::setPraId(std::string const& value) {
  m_PraId      = value;
  m_PraIdIsSet = true;
}
bool PresenceInfo::praIdIsSet() const {
  return m_PraIdIsSet;
}
void PresenceInfo::unsetPraId() {
  m_PraIdIsSet = false;
}
PresenceState PresenceInfo::getPresenceState() const {
  return m_PresenceState;
}
void PresenceInfo::setPresenceState(PresenceState const& value) {
  m_PresenceState      = value;
  m_PresenceStateIsSet = true;
}
bool PresenceInfo::presenceStateIsSet() const {
  return m_PresenceStateIsSet;
}
void PresenceInfo::unsetPresenceState() {
  m_PresenceStateIsSet = false;
}
std::vector<Tai>& PresenceInfo::getTrackingAreaList() {
  return m_TrackingAreaList;
}
bool PresenceInfo::trackingAreaListIsSet() const {
  return m_TrackingAreaListIsSet;
}
void PresenceInfo::unsetTrackingAreaList() {
  m_TrackingAreaListIsSet = false;
}
std::vector<Ecgi>& PresenceInfo::getEcgiList() {
  return m_EcgiList;
}
bool PresenceInfo::ecgiListIsSet() const {
  return m_EcgiListIsSet;
}
void PresenceInfo::unsetEcgiList() {
  m_EcgiListIsSet = false;
}
std::vector<Ncgi>& PresenceInfo::getNcgiList() {
  return m_NcgiList;
}
bool PresenceInfo::ncgiListIsSet() const {
  return m_NcgiListIsSet;
}
void PresenceInfo::unsetNcgiList() {
  m_NcgiListIsSet = false;
}
std::vector<GlobalRanNodeId>& PresenceInfo::getGlobalRanNodeIdList() {
  return m_GlobalRanNodeIdList;
}
bool PresenceInfo::globalRanNodeIdListIsSet() const {
  return m_GlobalRanNodeIdListIsSet;
}
void PresenceInfo::unsetGlobalRanNodeIdList() {
  m_GlobalRanNodeIdListIsSet = false;
}

}  // namespace model
}  // namespace amf
}  // namespace oai
