/**
 * NRF NFManagement Service
 * NRF NFManagement Service. Â© 2019, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.0.alpha-1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "InterfaceUpfInfoItem.h"

namespace oai {
namespace smf_server {
namespace model {

InterfaceUpfInfoItem::InterfaceUpfInfoItem() {
  m_Ipv4EndpointAddressesIsSet = false;
  m_Ipv6EndpointAddressesIsSet = false;
  m_EndpointFqdn               = "";
  m_EndpointFqdnIsSet          = false;
  m_NetworkInstance            = "";
  m_NetworkInstanceIsSet       = false;
}

InterfaceUpfInfoItem::~InterfaceUpfInfoItem() {}

void InterfaceUpfInfoItem::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json& j, const InterfaceUpfInfoItem& o) {
  j                  = nlohmann::json();
  j["interfaceType"] = o.m_InterfaceType;
  if (o.ipv4EndpointAddressesIsSet() || !o.m_Ipv4EndpointAddresses.empty())
    j["ipv4EndpointAddresses"] = o.m_Ipv4EndpointAddresses;
  if (o.ipv6EndpointAddressesIsSet() || !o.m_Ipv6EndpointAddresses.empty())
    j["ipv6EndpointAddresses"] = o.m_Ipv6EndpointAddresses;
  if (o.endpointFqdnIsSet()) j["endpointFqdn"] = o.m_EndpointFqdn;
  if (o.networkInstanceIsSet()) j["networkInstance"] = o.m_NetworkInstance;
}

void from_json(const nlohmann::json& j, InterfaceUpfInfoItem& o) {
  j.at("interfaceType").get_to(o.m_InterfaceType);
  if (j.find("ipv4EndpointAddresses") != j.end()) {
    j.at("ipv4EndpointAddresses").get_to(o.m_Ipv4EndpointAddresses);
    o.m_Ipv4EndpointAddressesIsSet = true;
  }
  if (j.find("ipv6EndpointAddresses") != j.end()) {
    j.at("ipv6EndpointAddresses").get_to(o.m_Ipv6EndpointAddresses);
    o.m_Ipv6EndpointAddressesIsSet = true;
  }
  if (j.find("endpointFqdn") != j.end()) {
    j.at("endpointFqdn").get_to(o.m_EndpointFqdn);
    o.m_EndpointFqdnIsSet = true;
  }
  if (j.find("networkInstance") != j.end()) {
    j.at("networkInstance").get_to(o.m_NetworkInstance);
    o.m_NetworkInstanceIsSet = true;
  }
}

UPInterfaceType InterfaceUpfInfoItem::getInterfaceType() const {
  return m_InterfaceType;
}
void InterfaceUpfInfoItem::setInterfaceType(UPInterfaceType const& value) {
  m_InterfaceType = value;
}
std::vector<std::string>& InterfaceUpfInfoItem::getIpv4EndpointAddresses() {
  return m_Ipv4EndpointAddresses;
}
void InterfaceUpfInfoItem::setIpv4EndpointAddresses(
    std::vector<std::string> const& value) {
  m_Ipv4EndpointAddresses      = value;
  m_Ipv4EndpointAddressesIsSet = true;
}
bool InterfaceUpfInfoItem::ipv4EndpointAddressesIsSet() const {
  return m_Ipv4EndpointAddressesIsSet;
}
void InterfaceUpfInfoItem::unsetIpv4EndpointAddresses() {
  m_Ipv4EndpointAddressesIsSet = false;
}
std::vector<Ipv6Addr>& InterfaceUpfInfoItem::getIpv6EndpointAddresses() {
  return m_Ipv6EndpointAddresses;
}
void InterfaceUpfInfoItem::setIpv6EndpointAddresses(
    std::vector<Ipv6Addr> const& value) {
  m_Ipv6EndpointAddresses      = value;
  m_Ipv6EndpointAddressesIsSet = true;
}
bool InterfaceUpfInfoItem::ipv6EndpointAddressesIsSet() const {
  return m_Ipv6EndpointAddressesIsSet;
}
void InterfaceUpfInfoItem::unsetIpv6EndpointAddresses() {
  m_Ipv6EndpointAddressesIsSet = false;
}
std::string InterfaceUpfInfoItem::getEndpointFqdn() const {
  return m_EndpointFqdn;
}
void InterfaceUpfInfoItem::setEndpointFqdn(std::string const& value) {
  m_EndpointFqdn      = value;
  m_EndpointFqdnIsSet = true;
}
bool InterfaceUpfInfoItem::endpointFqdnIsSet() const {
  return m_EndpointFqdnIsSet;
}
void InterfaceUpfInfoItem::unsetEndpointFqdn() {
  m_EndpointFqdnIsSet = false;
}
std::string InterfaceUpfInfoItem::getNetworkInstance() const {
  return m_NetworkInstance;
}
void InterfaceUpfInfoItem::setNetworkInstance(std::string const& value) {
  m_NetworkInstance      = value;
  m_NetworkInstanceIsSet = true;
}
bool InterfaceUpfInfoItem::networkInstanceIsSet() const {
  return m_NetworkInstanceIsSet;
}
void InterfaceUpfInfoItem::unsetNetworkInstance() {
  m_NetworkInstanceIsSet = false;
}

}  // namespace model
}  // namespace smf_server
}  // namespace oai
